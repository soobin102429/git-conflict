<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aggravated Assault Heatmap (D3)</title>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

  <style>
    :root{
      --bg:#0d1117; --panel:#161b22; --text:#e6edf3; --muted:#8b949e;
      --stroke:rgba(88,166,255,.12); --card:rgba(88,166,255,.05);
      --accent-low:#58a6ff; --accent-mid:#ffd657; --accent-high:#ff7b72;
      --shadow:0 8px 24px rgba(0,0,0,.4);
    }
    body{ margin:0; font-family:'Segoe UI',system-ui,-apple-system,sans-serif; background:var(--bg); color:var(--text); letter-spacing:0.4px; overflow-y:auto; }
    header{ display:flex; justify-content:space-between; align-items:center; padding:20px 28px;
      border-bottom:1px solid var(--stroke); background:rgba(13,17,23,.8); backdrop-filter:blur(12px); }
    header h1{ margin:0; font-size:18px; font-weight:700; letter-spacing:0.8px; text-transform:uppercase; color:var(--text); }
    header .hint{ color:var(--muted); font-size:12px; letter-spacing:0.5px; font-weight:500; }

    .grid{ display:grid; grid-template-columns: 1fr 420px; gap:20px; padding:20px 28px; min-height:calc(100vh - 61px); box-sizing:border-box; }
    .left{ background:rgba(22,27,34,.6); border:1px solid var(--stroke); border-radius:16px; overflow:hidden; position:relative; display:flex; flex-direction:column; box-shadow:var(--shadow); backdrop-filter:blur(8px); }
    .controls{ display:flex; gap:14px; align-items:center; padding:16px 18px; border-bottom:1px solid var(--stroke); flex-wrap:wrap; background:rgba(22,27,34,.4); }
    label{ font-size:12px; color:var(--muted); display:flex; align-items:center; gap:8px; font-weight:600; letter-spacing:0.4px; text-transform:uppercase; }
    select,input[type="range"]{ background:rgba(88,166,255,.08); color:var(--text); border:1px solid var(--stroke); border-radius:8px; padding:8px 12px; outline:none; font-size:12px; font-weight:500; transition:all 0.2s ease; }
    select:hover,input[type="range"]:hover{ background:rgba(88,166,255,.14); border-color:rgba(88,166,255,.4); }
    input[type="range"]{ padding:0; height:6px; }
    .pill{ font-size:12px; color:var(--text); padding:7px 14px; border:1px solid var(--stroke); border-radius:999px; background:rgba(88,166,255,.08); font-weight:600; letter-spacing:0.3px; }

    #mapWrap{ flex:1; position:relative; }
    svg{ width:100%; height:100%; display:block; }

    .tooltip{
      position:absolute; pointer-events:none; opacity:0; z-index:1000;
      background:rgba(13,17,23,.95); border:1px solid var(--stroke);
      border-radius:12px; padding:14px 16px; font-size:13px; min-width:220px;
      transform:translate(-50%,-110%);
      box-shadow:var(--shadow);
      backdrop-filter:blur(12px);
    }
    .tooltip .muted{ color:var(--muted); font-size:12px; margin-top:4px; }
    .tooltip > div:first-child{ font-weight:700; margin-bottom:8px; letter-spacing:0.3px; color:#58a6ff; font-size:13px; }

    .legend{
      position:absolute; top:20px; right:20px;
      background:rgba(13,17,23,.85); border:1px solid var(--stroke);
      border-radius:12px; padding:16px; font-size:12px; color:var(--muted);
      backdrop-filter:blur(12px);
      box-shadow:var(--shadow);
    }
    .legend > div:first-child{ font-weight:700; color:var(--text); margin-bottom:6px; font-size:13px; letter-spacing:0.3px; text-transform:uppercase; }
    .legend > div:nth-child(2){ font-size:11px; color:rgba(139,148,158,.7); margin-bottom:10px; font-weight:500; }
    .legend canvas{ display:block; margin-top:8px; border-radius:4px; border:1px solid rgba(255,255,255,.12); box-shadow:inset 0 2px 8px rgba(0,0,0,.2); }

    .right{ background:rgba(22,27,34,.6); border:1px solid var(--stroke); border-radius:16px; padding:20px; overflow:auto; box-shadow:var(--shadow); backdrop-filter:blur(8px); }
    .right::-webkit-scrollbar { width:6px; }
    .right::-webkit-scrollbar-track { background:rgba(255,255,255,.02); border-radius:999px; }
    .right::-webkit-scrollbar-thumb { background:rgba(255,255,255,.1); border-radius:999px; }

    .card{ background:rgba(88,166,255,.04); border:1px solid rgba(88,166,255,.15); border-radius:12px; padding:16px; margin-bottom:14px; transition:all 0.3s ease; }
    .card:first-child{ border:1.5px solid rgba(88,166,255,.3); background:rgba(88,166,255,.08); box-shadow:0 4px 12px rgba(88,166,255,.1); }
    .card:hover{ border-color:rgba(88,166,255,.3); background:rgba(88,166,255,.06); }
    .row{ display:flex; justify-content:space-between; gap:10px; align-items:baseline; }
    h2{ margin:0; font-size:13px; font-weight:700; letter-spacing:0.5px; text-transform:uppercase; color:#58a6ff; }
    .small{ color:var(--muted); font-size:12px; line-height:1.6; letter-spacing:0.2px; }

    .kpis{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px; }
    .kpi{ background:rgba(22,27,34,.8); border:1px solid rgba(88,166,255,.15); border-radius:10px; padding:14px; transition:all 0.2s ease; border-left:3px solid rgba(88,166,255,.4); }
    .kpi:hover{ background:rgba(22,27,34,.95); border-color:rgba(88,166,255,.3); }
    .kpi .k{ color:var(--muted); font-size:11px; font-weight:600; letter-spacing:0.3px; text-transform:uppercase; }
    .kpi .v{ margin-top:8px; font-size:18px; font-weight:700; color:#58a6ff; }

    .state{ cursor:pointer; stroke:var(--bg); stroke-width:1.5; vector-effect:non-scaling-stroke; transition:all 0.2s ease; filter:drop-shadow(0 2px 6px rgba(0,0,0,.25)); }
    .state:hover{ stroke:rgba(88,166,255,.6); stroke-width:2; filter:drop-shadow(0 4px 12px rgba(88,166,255,.3)); }
    .state:focus{ outline:none; stroke:#58a6ff; stroke-width:2.5; filter:drop-shadow(0 6px 16px rgba(88,166,255,.4)); }
    .state.pinned{ stroke:#58a6ff; stroke-width:2.5; filter:drop-shadow(0 0px 12px rgba(88,166,255,.4)); }
    .state.compared{ stroke:#ffd657; stroke-width:2.2; filter:drop-shadow(0 0px 12px rgba(255,214,87,.6)); }
    .state.compared:hover{ stroke:#ffd657; stroke-width:2.5; filter:drop-shadow(0 0px 16px rgba(255,214,87,.8)); }

    #insightsSection{
      padding:20px 28px; background:transparent; display:block; width:100%; margin-top:20px; margin-bottom:40px; box-sizing:border-box;
    }
    .insight-chart-wrapper{
      background:rgba(22,27,34,.6); border:1px solid var(--stroke); border-radius:16px;
      padding:20px; box-shadow:var(--shadow); backdrop-filter:blur(8px); margin-bottom:20px; width:100%; box-sizing:border-box;
      overflow-x:auto;
    }
    .insight-chart-wrapper h3{
      margin:0 0 12px 0; font-size:14px; font-weight:700; letter-spacing:0.4px;
      text-transform:uppercase; color:#58a6ff;
    }
    .insight-chart-wrapper svg{ 
      display:block; background:transparent;
    }
    #trendChartContainer, #scatterChartContainer, #stackedChartContainer, #heatmapChartContainer {
      min-height:320px; width:100%; box-sizing:border-box;
    }

    @media (max-width: 1200px){ .grid{ grid-template-columns: 1fr 350px; gap:14px; } }
    @media (max-width: 900px){ .grid{ grid-template-columns:1fr; height:auto; } .right{ max-height:none; } }
  </style>
</head>
<body>
<header>
  <h1>Aggravated Assault â€¢ State Heatmap</h1>
  <div style="display:flex; gap:12px; align-items:center;">
    <button id="compareBtn" style="background:rgba(88,166,255,.2); border:1px solid rgba(88,166,255,.4); color:#58a6ff; padding:7px 14px; border-radius:6px; font-size:12px; font-weight:600; cursor:pointer; transition:all 0.2s ease;" 
            onclick="toggleCompareMode();"
            onmouseover="if(!window.isCompareMode) { this.style.background='rgba(88,166,255,.3)'; this.style.borderColor='rgba(88,166,255,.6)'; }" 
            onmouseout="if(!window.isCompareMode) { this.style.background='rgba(88,166,255,.2)'; this.style.borderColor='rgba(88,166,255,.4)'; }">
      ðŸ“Š Compare (0)
    </button>
    <div class="hint" id="hint">Hover = preview â€¢ Click = pin panel</div>
  </div>
</header>

<div class="grid">
  <section class="left">
    <div class="controls">
      <label>Metric
        <select id="metric">
          <option value="rate_per_100k">Offenses per 100k</option>
          <option value="offenses">Offenses (count)</option>
          <option value="clearance_rate">Clearance rate</option>
          <option value="clearances">Clearances (count)</option>
        </select>
      </label>

      <label>Scale
        <select id="scaleMode">
          <option value="relative">Relative (monthly)</option>
          <option value="fixed">Fixed (5-year)</option>
        </select>
      </label>

      <label>Month
        <input id="month" type="range" min="0" max="0" step="1" value="0" />
      </label>

      <div class="pill" id="monthLabel">â€”</div>
    </div>

    <div id="mapWrap">
      <div class="legend" id="legend"></div>
      <div class="tooltip" id="tooltip"></div>
      <svg id="svg"></svg>
    </div>
  </section>

  <aside class="right">
    <div class="card">
      <div class="row">
        <h2 id="pTitle">Select a state</h2>
        <div class="small" id="pMonth">â€”</div>
      </div>
      <div class="small" id="pMetric">â€”</div>
    </div>

    <div class="card">
      <div class="row"><h2>Rankings</h2><div class="small" id="rankMonth">â€”</div></div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:10px;">
        <div>
          <div class="small" style="font-weight:600; margin-bottom:6px; color:#ff7b72;">ðŸ”´ Top 10</div>
          <div id="topList" style="font-size:11px;"></div>
        </div>
        <div>
          <div class="small" style="font-weight:600; margin-bottom:6px; color:#58a6ff;">ðŸ”µ Bottom 10</div>
          <div id="bottomList" style="font-size:11px;"></div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="row"><h2>Key stats</h2><div class="small" id="pinHint">Not pinned</div></div>
      <div class="kpis" id="kpis"></div>
    </div>

    <div class="card">
      <h2 style="margin-bottom:6px;">State Profile</h2>
      <div id="dataQuality" style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;"></div>
      <svg id="radarSvg" width="320" height="240" style="background:transparent;border-radius:8px" role="img" aria-label="State risk profile radar"></svg>
    </div>

    <div class="card">
      <h2 style="margin-bottom:6px;">Notes</h2>
      <div class="small" style="line-height:1.5;">
        â€¢ Clearance counts are usually far smaller than offenses.<br/>
        â€¢ Use per-100k for cross-state comparisons.<br/>
        â€¢ Click same state again to unpin.
      </div>
    </div>

    <div class="card">
      <h2 style="margin-bottom:6px;">Trends (US total)</h2>
      <div class="small" style="margin-bottom:8px;">Monthly incidents vs clearances</div>
      <svg id="tsSvg" width="320" height="140" style="background:transparent;border-radius:8px" role="img" aria-label="Time series of incidents and clearances"></svg>
    </div>

    <div class="card">
      <h2 style="margin-bottom:6px;">Demographics (sample)</h2>
      <div class="small" style="margin-bottom:8px;">Offender age distribution</div>
      <svg id="ageSvg" width="320" height="180"></svg>
      <div class="small" style="margin-top:8px;margin-bottom:6px;">Offender sex</div>
      <svg id="sexSvg" width="320" height="120"></svg>
    </div>

    <div class="card">
      <h2 style="margin-bottom:6px;">Flow (sample)</h2>
      <div class="small" style="margin-bottom:8px;">Location â†’ Weapon â†’ Offense (drilldown sample)</div>
      <svg id="sankeySvg" width="320" height="240" role="img" aria-label="Sample sankey flow of location to weapon to offense"></svg>
    </div>
  </aside>
</div>

<section id="insightsSection">
  <h2 style="font-size:16px; font-weight:700; letter-spacing:0.5px; text-transform:uppercase; color:#58a6ff; margin:0 28px 16px; padding-top:20px;">Insights & Analysis</h2>
  
  <div class="insight-chart-wrapper">
    <h3>Trend Line (Selected State vs US Average)</h3>
    <div id="trendChartContainer"></div>
  </div>

  <div class="insight-chart-wrapper">
    <h3>Scatter Plot (Clearance Rate vs Offenses)</h3>
    <div id="scatterChartContainer"></div>
  </div>

  <div class="insight-chart-wrapper">
    <h3>Weapon Composition (100% Stacked)</h3>
    <div id="stackedChartContainer"></div>
  </div>

  <div class="insight-chart-wrapper">
    <h3>Location Ã— Weapon Heatmap</h3>
    <div id="heatmapChartContainer"></div>
  </div>
</section>

<script>
(async function(){
  // ---------- DOM ----------
  const svg = d3.select("#svg");
  const mapWrap = document.getElementById("mapWrap");
  const tooltip = d3.select("#tooltip").attr('role','status').attr('aria-live','polite');
  const legend  = d3.select("#legend");

  const metricSel = d3.select("#metric");
  const monthRange= d3.select("#month");
  const monthLabel= d3.select("#monthLabel");
  const scaleMode = d3.select("#scaleMode");

  const pTitle = d3.select("#pTitle");
  const pMonth = d3.select("#pMonth");
  const pMetric= d3.select("#pMetric");
  const pinHint= d3.select("#pinHint");
  const kpis   = d3.select("#kpis");
  const topList= d3.select("#topList");
  const bottomList= d3.select("#bottomList");
  const rankMonth= d3.select("#rankMonth");

  // ---------- Formatters ----------
  const META = {
    rate_per_100k: {label:"Offenses per 100k", fmt:d3.format(",.1f")},
    offenses: {label:"Offenses", fmt:d3.format(",")},
    clearance_rate: {label:"Clearance rate", fmt:d => (d*100).toFixed(1)+"%"},
    clearances: {label:"Clearances", fmt:d3.format(",")}
  };
  
  // Custom heatmap: low (cool blue) â†’ medium (amber) â†’ high (deep red)
  const ramp = t => {
    if(t < 0.33) {
      const s = t / 0.33;
      return d3.interpolate("#58a6ff", "#ffd657")(s);
    } else if(t < 0.66) {
      const s = (t - 0.33) / 0.33;
      return d3.interpolate("#ffd657", "#ff9d76")(s);
    } else {
      const s = (t - 0.66) / 0.34;
      return d3.interpolate("#ff9d76", "#ff7b72")(s);
    }
  };

  // ---------- Load map ----------
  const us = await d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json");
  const states = topojson.feature(us, us.objects.states).features;

  // ---------- Load data ----------
  // Expected columns:
  // month,state_fips,state_abbr,state_name,offenses,clearances,population
  const raw = await d3.csv("data/state_month.csv", d => ({
    month: d.month,
    fips: +d.state_fips,
    abbr: d.state_abbr,
    name: d.state_name,
    offenses: +d.offenses || 0,
    clearances: +d.clearances || 0,
    population: +d.population || 0
  }));

  const months = Array.from(new Set(raw.map(d=>d.month))).sort();
  monthRange.attr("max", months.length-1).attr("value", months.length-1);
  monthLabel.text(months[months.length-1]);

  // month -> fips -> record (fast lookup)
  const idx = d3.group(raw, d=>d.month, d=>d.fips);

  function rec(month, fips){
    const m = idx.get(month);
    if(!m) return null;
    const arr = m.get(fips);
    if(!arr || !arr.length) return null;
    const r = arr[0];
    const clearance_rate = r.offenses ? r.clearances / r.offenses : 0;
    const rate_per_100k  = r.population ? (r.offenses / r.population)*100000 : 0;
    return {...r, clearance_rate, rate_per_100k};
  }

  // ---------- Projection / resize ----------
  const projection = d3.geoAlbersUsa();
  const path = d3.geoPath(projection);

  function fit(){
    const w = mapWrap.clientWidth, h = mapWrap.clientHeight;
    svg.attr("viewBox", `0 0 ${w} ${h}`);
    projection.fitSize([w,h], {type:"FeatureCollection", features:states});
  }
  fit();
  window.addEventListener("resize", () => { fit(); render(); });

  // ---------- Legend (compact) ----------
  function drawLegend(scale, metric, month, mode){
    legend.html("");
    const title = legend.append("div").text(META[metric].label);
    const subtitle = legend.append("div").text(`${month} (${mode === "fixed" ? "Fixed 5y" : "Relative"})`);

    const canvas = legend.append("canvas").attr("width",160).attr("height",12).node();
    const ctx = canvas.getContext("2d");
    const img = ctx.createImageData(160,12);
    for(let x=0; x<160; x++){
      const color = ramp(x/159);
      const c = d3.rgb(color);
      for(let y=0; y<12; y++){
        const i=(y*160+x)*4;
        img.data[i]=c.r; img.data[i+1]=c.g; img.data[i+2]=c.b; img.data[i+3]=255;
      }
    }
    ctx.putImageData(img,0,0);

    const min = d3.min(scale.domain()), max = d3.max(scale.domain());
    const row = legend.append("div").style("display","flex").style("justify-content","space-between").style("gap","10px").style("margin-top","8px");
    row.append("div").style("font-size","11px").style("font-weight","500").text("Lower: " + META[metric].fmt(min));
    row.append("div").style("font-size","11px").style("font-weight","500").text("Higher: " + META[metric].fmt(max));

    // No data indicator
    const noDataRow = legend.append("div").style("display","flex").style("align-items","center").style("gap","6px").style("margin-top","10px").style("font-size","10px").style("color","rgba(139,148,158,.7)");
    noDataRow.append("rect").attr("width",12).attr("height",12).attr("fill","#3d444d").attr("rx","2");
    noDataRow.append("text").text("No data/missing");
  }

  // ---------- Panel ----------
  let pinned = null;
  let isCompareMode = false;
  let comparedStates = [];
  const compareBtn = document.getElementById("compareBtn");
  const hintEl = document.getElementById("hint");

  // RESET APP STATE - Complete initialization
  // ========== ROBUST RENDER PIPELINE HELPERS ==========
  
  // Get element size safely - handles 0 width/height
  function getSize(el) {
    if (!el) return {w: 700, h: 300};
    const rect = el.getBoundingClientRect();
    let w = rect.width || el.offsetWidth || el.clientWidth;
    let h = rect.height || el.offsetHeight || el.clientHeight;
    
    // Fallback to parent if element has 0 size
    if ((!w || w === 0) && el.parentElement) {
      const parentRect = el.parentElement.getBoundingClientRect();
      w = parentRect.width - 40; // account for padding
    }
    if ((!h || h === 0)) {
      h = 300; // default height
    }
    
    return {
      w: Math.max(250, w),
      h: Math.max(150, h)
    };
  }

  // Schedule render with retry logic - waits for non-zero size
  function scheduleRender(el, renderFn, maxRetries = 10) {
    let retries = 0;
    
    function tryRender() {
      if (!el) return;
      
      const {w, h} = getSize(el);
      
      // If size is valid, render
      if (w > 250 && h > 150) {
        console.log(`[scheduleRender] Rendering with size ${w}x${h}`);
        try {
          renderFn(el, w, h);
        } catch (e) {
          console.error("[scheduleRender] Error:", e);
        }
      } else if (retries < maxRetries) {
        // Retry on next frame
        retries++;
        requestAnimationFrame(tryRender);
      } else {
        console.warn(`[scheduleRender] Max retries exceeded for`, el.id, `size: ${w}x${h}`);
      }
    }
    
    requestAnimationFrame(tryRender);
  }

  // Update all charts safely
  function updateAllCharts() {
    console.log("[updateAllCharts] Updating all insight charts...");
    try {
      updateTrendChartBelow();
    } catch (e) { console.error("[updateAllCharts] Trend error:", e); }
    try {
      updateScatterChart();
    } catch (e) { console.error("[updateAllCharts] Scatter error:", e); }
    try {
      updateHeatmapChart();
    } catch (e) { console.error("[updateAllCharts] Heatmap error:", e); }
    try {
      updateStackedChart();
    } catch (e) { console.error("[updateAllCharts] Stacked error:", e); }
  }

  // ========== ENHANCED RESET STATE ==========
  function resetAppState(){
    console.log("[resetAppState] Resetting to initial state");
    
    // 1. Exit compare mode
    isCompareMode = false;
    comparedStates = [];
    pinned = null;
    
    // 2. Reset compare button styling
    if(compareBtn){
      compareBtn.style.background = "rgba(88,166,255,.2)";
      compareBtn.style.borderColor = "rgba(88,166,255,.4)";
      compareBtn.style.color = "#58a6ff";
      compareBtn.style.opacity = "0.6";
      compareBtn.textContent = "ðŸ“Š Compare (0)";
    }
    
    // 3. Clear sidebar panel
    pTitle.text("Select a state");
    pMonth.text("â€”");
    pMetric.text("â€”");
    kpis.html("");
    topList.html("");
    bottomList.html("");
    pinHint.text("Not pinned");
    
    // 4. Reset hint text
    if(hintEl) hintEl.textContent = "Hover = preview â€¢ Click = pin panel";
    
    // 5. Remove map highlights
    svg.selectAll("path.state")
      .classed("pinned", false)
      .classed("compared", false);
    
    // 6. Hide comparison card
    const compCard = document.getElementById("comparisonCard");
    if(compCard) compCard.style.display = "none";
    
    // 7. Clear tooltip
    tooltip.style("opacity", 0).html("");
    
    // 8. Reset insights charts to default/placeholder
    updateAllCharts();
    
    // 9. Re-render all sidebar charts with default state
    const currentMonth = months[months.length - 1];
    renderTimeSeries();
    renderAgeChart();
    renderSexChart();
    renderSankey();
    renderRankings(currentMonth);
    
    // 10. Scroll to top (optional but helpful)
    window.scrollTo({top: 0, behavior: 'smooth'});
  }

  // Calculate 12-month trend
  function calculateTrend(fips){
    const currentMonth = months[months.length - 1];
    const currIdx = months.indexOf(currentMonth);
    
    // Current 12 months
    const curr12Start = Math.max(0, currIdx - 11);
    const curr12Offenses = d3.sum(months.slice(curr12Start, currIdx + 1), m => {
      const r = rec(m, fips);
      return r ? r.offenses : 0;
    });
    
    // Previous 12 months
    const prev12Start = Math.max(0, currIdx - 23);
    const prev12End = curr12Start;
    const prev12Offenses = d3.sum(months.slice(prev12Start, prev12End), m => {
      const r = rec(m, fips);
      return r ? r.offenses : 0;
    });
    
    if(prev12Offenses === 0) return 0;
    const pctChange = ((curr12Offenses - prev12Offenses) / prev12Offenses) * 100;
    return pctChange;
  }

  // Calculate clearance rate 12m trend
  function calculateClearanceTrend(fips){
    const currentMonth = months[months.length - 1];
    const currIdx = months.indexOf(currentMonth);
    
    // Current 12m clearance rate
    const curr12Start = Math.max(0, currIdx - 11);
    const curr12Data = months.slice(curr12Start, currIdx + 1).map(m => rec(m, fips)).filter(r => r);
    const curr12Rate = curr12Data.length ? d3.sum(curr12Data, d => d.clearances) / d3.sum(curr12Data, d => d.offenses) : 0;
    
    // Previous 12m clearance rate
    const prev12Start = Math.max(0, currIdx - 23);
    const prev12End = curr12Start;
    const prev12Data = months.slice(prev12Start, prev12End).map(m => rec(m, fips)).filter(r => r);
    const prev12Rate = prev12Data.length ? d3.sum(prev12Data, d => d.clearances) / d3.sum(prev12Data, d => d.offenses) : 0;
    
    const change = (curr12Rate - prev12Rate) * 100;
    return change;
  }

  // Calculate z-scores for radar
  function calculateZScores(fips, month){
    // Get all states' values for this month
    const allStates = states.map(s => {
      const r = rec(month, +s.id);
      return r ? {rate100k: r.rate_per_100k, trend: calculateTrend(+s.id), firearm: 0.3, stranger: 0.4, clearInv: 1 - r.clearance_rate} : null;
    }).filter(d => d);

    const r = rec(month, fips);
    if(!r) return null;

    const trend = calculateTrend(fips);
    const clearInv = 1 - r.clearance_rate;

    // Compute z-scores
    const rate100kMean = d3.mean(allStates, d => d.rate100k);
    const rate100kStd = Math.sqrt(d3.mean(allStates, d => Math.pow(d.rate100k - rate100kMean, 2)));
    const rateZ = (r.rate_per_100k - rate100kMean) / (rate100kStd || 1);

    const trendMean = d3.mean(allStates, d => d.trend);
    const trendStd = Math.sqrt(d3.mean(allStates, d => Math.pow(d.trend - trendMean, 2)));
    const trendZ = (trend - trendMean) / (trendStd || 1);

    return {
      rateZ: Math.max(-2, Math.min(2, rateZ)),
      trendZ: Math.max(-2, Math.min(2, trendZ)),
      firearm: 0.3,
      stranger: 0.4,
      clearInv: Math.min(1, clearInv),
      trend: trend,
      clearanceTrend: calculateClearanceTrend(fips)
    };
  }

  // ---------- Radar chart for state profile ----------
  function renderRadar(month, fips){
    const svg = d3.select('#radarSvg');
    svg.selectAll('*').remove();
    
    const width = +svg.attr('width');
    const height = +svg.attr('height');
    const radius = Math.min(width, height) / 2 - 30;
    const center = {x: width / 2, y: height / 2};

    const scores = calculateZScores(month, fips);
    if(!scores) return;

    // Normalize scores to 0-1 range for visualization
    const normalize = (z) => Math.max(0, Math.min(1, (z + 2) / 4));

    const axes = [
      {name: 'Rate/100k', value: normalize(scores.rateZ), color: '#ff7b72'},
      {name: 'Trend â†‘', value: normalize(scores.trendZ), color: '#ffd657'},
      {name: 'Clearance', value: 1 - scores.clearInv, color: '#10b981'},
      {name: 'Firearm', value: scores.firearm, color: '#58a6ff'},
      {name: 'Stranger', value: scores.stranger, color: '#79c0ff'}
    ];

    const angleSlice = (Math.PI * 2) / axes.length;
    const g = svg.append('g').attr('transform', `translate(${center.x},${center.y})`);

    // Draw concentric circles (grid)
    for(let i = 1; i <= 3; i++){
      const r = (radius / 3) * i;
      g.append('circle')
        .attr('r', r)
        .attr('fill', 'none')
        .attr('stroke', 'rgba(88,166,255,.1)')
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '2 2');
    }

    // Draw axes
    axes.forEach((axis, i) => {
      const angle = angleSlice * i - Math.PI / 2;
      const x = Math.cos(angle) * radius;
      const y = Math.sin(angle) * radius;
      
      g.append('line')
        .attr('x1', 0).attr('y1', 0)
        .attr('x2', x).attr('y2', y)
        .attr('stroke', 'rgba(88,166,255,.15)')
        .attr('stroke-width', 1);

      // Labels
      const labelR = radius + 20;
      const lx = Math.cos(angle) * labelR;
      const ly = Math.sin(angle) * labelR;
      g.append('text')
        .attr('x', lx).attr('y', ly)
        .attr('text-anchor', 'middle')
        .attr('dy', '0.35em')
        .text(axis.name)
        .style('font-size', '10px')
        .style('fill', 'rgba(139,148,158,.8)')
        .style('font-weight', '500');
    });

    // Draw polygon (profile)
    const points = axes.map((axis, i) => {
      const angle = angleSlice * i - Math.PI / 2;
      const r = axis.value * radius;
      return {x: Math.cos(angle) * r, y: Math.sin(angle) * r, color: axis.color};
    });

    // Fill
    const pathData = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ') + ' Z';
    g.append('path')
      .attr('d', pathData)
      .attr('fill', 'rgba(88,166,255,.15)')
      .attr('stroke', '#58a6ff')
      .attr('stroke-width', 2);

    // Nodes
    points.forEach((p, i) => {
      g.append('circle')
        .attr('cx', p.x).attr('cy', p.y)
        .attr('r', 4)
        .attr('fill', p.color)
        .attr('stroke', 'rgba(13,17,23,.8)')
        .attr('stroke-width', 1)
        .style('filter', 'drop-shadow(0 1px 3px rgba(0,0,0,.2))');
    });
  }

  function setPanel(month, fips, isPinned){
    const r = rec(month, fips);
    if(!r){
      pTitle.text("No data");
      pMonth.text(month);
      pMetric.text(META[metricSel.node().value].label);
      kpis.html("");
      d3.select("#dataQuality").html("");
      d3.select("#radarSvg").html("");
      return;
    }
    pTitle.text(`${r.name}`).style("color", "var(--text)").style("font-size", "14px").style("font-weight", "600");
    pMonth.style("color", "var(--muted)").style("font-size", "11px").text(month);
    pMetric.text(META[metricSel.node().value].label).style("color", "var(--muted)").style("font-size", "11px").style("margin-top", "4px").style("display", "block");
    pinHint.text(isPinned ? "ðŸ“Œ Pinned" : "ðŸ‘ Preview").style("color", isPinned ? "#60a5fa" : "var(--muted)").style("font-weight", isPinned ? "500" : "400");

    // Calculate trends
    const trend12m = calculateTrend(fips);
    const clearanceTrend = calculateClearanceTrend(fips);
    const trendColor = trend12m > 0 ? "#ff7b72" : "#10b981";
    const clearTrendColor = clearanceTrend > 0 ? "#10b981" : "#ff7b72";
    const trendIcon = trend12m > 0 ? "ðŸ“ˆ" : "ðŸ“‰";
    const clearIcon = clearanceTrend > 0 ? "ðŸ“ˆ" : "ðŸ“‰";

    const rows = [
      {k:"Offenses", v:d3.format(",")(r.offenses), color:"#58a6ff"},
      {k:"Trend (12m)", v:trendIcon + " " + Math.abs(trend12m).toFixed(1) + "%", color:trendColor},
      {k:"Clearances", v:d3.format(",")(r.clearances), color:"#8b5cf6"},
      {k:"Clear. Trend", v:clearIcon + " " + Math.abs(clearanceTrend).toFixed(1) + "%", color:clearTrendColor},
      {k:"Clearance rate", v:((r.clearance_rate||0)*100).toFixed(1)+"%", color:"#10b981"},
      {k:"Per 100k", v:d3.format(",.1f")(r.rate_per_100k), color:"#ffd657"}
    ];
    const sel = kpis.selectAll(".kpi").data(rows, d=>d.k);
    sel.enter().append("div").attr("class","kpi")
      .style("border-left", d=>`3px solid ${d.color}`)
      .html(d=>{
        const isTrend = d.k.includes("Trend");
        return `<div class="k">${d.k}</div><div class="v" style="${isTrend ? "font-size:16px;" : ""}">${d.v}</div>`;
      });
    sel.style("border-left", d=>`3px solid ${d.color}`)
      .html(d=>{
        const isTrend = d.k.includes("Trend");
        return `<div class="k">${d.k}</div><div class="v" style="${isTrend ? "font-size:16px;" : ""}">${d.v}</div>`;
      });
    sel.exit().remove();

    // Data Quality
    const dataQualityHTML = `
      <div style="flex:1; min-width:140px; background:rgba(16,185,129,.08); border:1px solid rgba(16,185,129,.2); border-radius:8px; padding:8px; text-align:center;">
        <div style="font-size:10px; color:rgba(139,148,158,.8); font-weight:500;">Relationship Known</div>
        <div style="font-size:14px; font-weight:700; color:#10b981; margin-top:2px;">92%</div>
        <div style="font-size:9px; color:rgba(139,148,158,.6); margin-top:2px;">High confidence</div>
      </div>
      <div style="flex:1; min-width:140px; background:rgba(88,166,255,.08); border:1px solid rgba(88,166,255,.2); border-radius:8px; padding:8px; text-align:center;">
        <div style="font-size:10px; color:rgba(139,148,158,.8); font-weight:500;">Reporting Completeness</div>
        <div style="font-size:14px; font-weight:700; color:#58a6ff; margin-top:2px;">88%</div>
        <div style="font-size:9px; color:rgba(139,148,158,.6); margin-top:2px;">Recent 12m</div>
      </div>
    `;
    d3.select("#dataQuality").html(dataQualityHTML);

    // Radar chart
    renderRadar(month, fips);
    
    // Render insights charts (both sidebar + below-map)
    renderTimeSeries(); // Sidebar time series
    updateTrendChartBelow(); // Below-map trend
    renderInsights(); // Scatter, Heatmap, Stacked
  }

  // ---------- Render ----------
  const g = svg.append("g");

  // Calculate fixed (5-year) domain for each metric
  const fixedDomains = {};
  Object.keys(META).forEach(metric => {
    const vals = states.map(s => {
      return d3.max(months, month => {
        const r = rec(month, +s.id);
        return r ? r[metric] : null;
      });
    }).filter(v => v != null && isFinite(v));
    fixedDomains[metric] = [0, d3.max(vals)];
  });

  function getDomain(metric, month, mode) {
    if (mode === "fixed") {
      return fixedDomains[metric];
    } else {
      // relative: monthly min/max
      const vals = states.map(s => {
        const r = rec(month, +s.id);
        return r ? r[metric] : null;
      }).filter(v => v != null && isFinite(v));
      return vals.length ? [d3.min(vals), d3.max(vals)] : [0, 1];
    }
  }

  function render(){
    const month = months[+monthRange.node().value];
    const metric = metricSel.node().value;
    const mode = scaleMode.node().value;
    monthLabel.text(month);

    // quantile scale gives good "heatmap" separation under skewed distributions
    const domain = getDomain(metric, month, mode);
    const scale = d3.scaleQuantile().domain(domain.length > 1 ? [domain[0], domain[1]] : [0,1]).range(d3.range(9).map(i=>ramp(i/8)));

    drawLegend(scale, metric, month, mode);

    const sel = g.selectAll("path.state").data(states, d=>d.id);

    sel.enter().append("path")
      .attr("class","state")
      .attr("d", path)
      .attr("tabindex",0)
      .attr('role','button')
      .attr('aria-label', d => `State ${d.properties && d.properties.name ? d.properties.name : d.id}`)
      .attr("fill", d => {
        const r = rec(month, +d.id);
        if(!r || !isFinite(r[metric])) return "#3d444d";
        
        const color = scale(r[metric]);
        
        // In compare mode, desaturate unselected states
        if(isCompareMode && comparedStates.length > 0 && !comparedStates.includes(+d.id)){
          const rgb = d3.rgb(color);
          const gray = (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114) * 0.6;
          return d3.rgb(gray * 0.7, gray * 0.72, gray * 0.75).toString();
        }
        return color;
      })
      .on("mousemove", (event, d) => {
        if(isCompareMode) return; // No tooltip in compare mode
        
        const r = rec(month, +d.id);
        const meta = META[metric];
        const value = r && isFinite(r[metric]) ? meta.fmt(r[metric]) : "Missing";
        const statusColor = r && isFinite(r[metric]) ? "#58a6ff" : "#8b949e";

        tooltip
          .style("opacity", 1)
          .style("left", event.offsetX + "px")
          .style("top",  event.offsetY + "px")
          .html(`
            <div style="font-weight:700; color:${statusColor};">
              ${(r?.name)||"Unknown"}
            </div>
            <div class="muted" style="margin-top:4px; margin-bottom:6px;">${month}</div>
            <div style="display:flex; flex-direction:column; gap:4px;">
              <div><span class="muted">${meta.label}:</span> <b style="color:${statusColor};">${value}</b></div>
              ${r && isFinite(r[metric]) ? `<div><span class="muted">Offenses:</span> ${d3.format(",")(r.offenses)}</div>` : ``}
              ${r && isFinite(r[metric]) ? `<div><span class="muted">Rate/100k:</span> ${d3.format(",.0f")(r.rate_per_100k)}</div>` : ``}
              ${r && isFinite(r[metric]) ? `<div><span class="muted">Clear rate:</span> ${((r.clearance_rate||0)*100).toFixed(1)}%</div>` : `<div style="color:#8b949e; font-style:italic; font-size:11px;">No data</div>`}
            </div>
          `);

        if(pinned == null && !isCompareMode) setPanel(month, +d.id, false);
      })
      .on("mouseleave", () => {
        tooltip.style("opacity", 0);
        if(pinned == null){
          pTitle.text("Select a state");
          pMonth.text("â€”");
          pMetric.text("â€”");
          pinHint.text("Not pinned");
          kpis.html("");
        }
      })
      .on("mouseover", (event, d) => {
        // In compare mode, highlight on hover to indicate clickability
        if(isCompareMode){
          d3.select(event.target)
            .style("opacity", comparedStates.includes(+d.id) ? "1" : "0.7");
        }
      })
      .on('focus', (event,d)=>{
        // keyboard focus shows panel preview
        if(!isCompareMode){
          const month = months[+monthRange.node().value];
          setPanel(month, +d.id, false);
        }
      })
      .on('keydown', (event,d)=>{
        if(event.key === 'Enter' || event.key === ' '){
          event.preventDefault();
          const id = +d.id;
          if(isCompareMode){
            window.addStateToCompare(id);
          }else{
            pinned = (pinned === id) ? null : id;
            if(pinned != null){ setPanel(months[+monthRange.node().value], pinned, true); }
            else { pTitle.text('Select a state'); pMonth.text('â€”'); pMetric.text('â€”'); pinHint.text('Not pinned'); kpis.html(''); }
          }
        }
      })
      .on("click", (event, d) => {
        const id = +d.id;
        if(isCompareMode){
          window.addStateToCompare(id);
        }else{
          pinned = (pinned === id) ? null : id;
          if(pinned != null){
            setPanel(month, pinned, true);
            svg.selectAll("path.state")
              .classed("pinned", s => +s.id === pinned)
              .classed("compared", false);
          }else{
            pTitle.text("Select a state");
            pMonth.text("â€”");
            pMetric.text("â€”");
            pinHint.text("Not pinned");
            kpis.html("");
            svg.selectAll("path.state").classed("pinned", false);
          }
        }
      });

    sel.attr("d", path)
      .transition().duration(220)
      .attr("fill", d => {
        const r = rec(month, +d.id);
        if(!r || !isFinite(r[metric])) return "#3d444d";
        
        const color = scale(r[metric]);
        
        // In compare mode, desaturate unselected states
        if(isCompareMode && comparedStates.length > 0 && !comparedStates.includes(+d.id)){
          const rgb = d3.rgb(color);
          // Convert to grayscale with slight tint
          const gray = (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114) * 0.6;
          return d3.rgb(gray * 0.7, gray * 0.72, gray * 0.75).toString();
        }
        return color;
      });

    sel.exit().remove();

    // Render Top 10 / Bottom 10 rankings
    renderRankings(month, metric);

    if(pinned != null) setPanel(month, pinned, true);
  }

  function renderRankings(month, metric){
    const data = states.map(s => {
      const r = rec(month, +s.id);
      return r && isFinite(r[metric]) ? {id: +s.id, name: r.name, abbr: r.abbr, value: r[metric]} : null;
    }).filter(d => d != null);

    data.sort((a,b) => b.value - a.value);
    const top10 = data.slice(0, 10);
    const bottom10 = data.slice(-10).reverse();

    rankMonth.text(month);

    const itemStyle = `
      padding:8px 6px;
      cursor:pointer;
      border-bottom:1px solid rgba(88,166,255,.08);
      border-radius:4px;
      margin-bottom:2px;
      transition:all 0.2s ease;
      display:flex;
      align-items:center;
      justify-content:space-between;
    `;

    // Top 10
    topList.html(top10.map((d,i) => `
      <div style="${itemStyle} background:rgba(255,123,114,.04);" 
           class="ranking-item"
           onclick="window.pinState(${d.id}, true)">
        <span><span style="color:#ff7b72; font-weight:700;">${i+1}</span> ${d.abbr}</span>
        <span style="color:rgba(255,123,114,.8); font-weight:600; font-size:10px;">${META['${metric}'].fmt(d.value)}</span>
      </div>
    `).join(''));

    // Bottom 10
    bottomList.html(bottom10.map((d,i) => `
      <div style="${itemStyle} background:rgba(88,166,255,.04);" 
           class="ranking-item"
           onclick="window.pinState(${d.id}, true)">
        <span><span style="color:#58a6ff; font-weight:700;">${i+1}</span> ${d.abbr}</span>
        <span style="color:rgba(88,166,255,.8); font-weight:600; font-size:10px;">${META['${metric}'].fmt(d.value)}</span>
      </div>
    `).join(''));

    // Add hover effects
    d3.selectAll(".ranking-item")
      .on("mouseover", function(){ d3.select(this).style("background", d3.select(this).style("color").includes("255,123") ? "rgba(255,123,114,.08)" : "rgba(88,166,255,.08)"); })
      .on("mouseout", function(){ d3.select(this).style("background", d3.select(this).style("color").includes("255,123") ? "rgba(255,123,114,.04)" : "rgba(88,166,255,.04)"); });
  }

  // (Old renderScatterInsight removed - replaced by updateScatterChart)

  // (Old renderHeatmapInsight removed - replaced by updateHeatmapChart)


  // Initial insight render - called when data/month/pinned changes
  window.renderInsights = function(){
    console.log("[renderInsights] Called (delegating to updateAllCharts)");
    updateAllCharts();
  };

  // Exposed function for ranking list clicks
  window.pinState = function(fips, isCurrent){
    if(isCompareMode){
      window.addStateToCompare(fips);
      return;
    }
    const currentId = +fips;
    pinned = (pinned === currentId) ? null : currentId;
    if(pinned != null){
      setPanel(months[+monthRange.node().value], pinned, true);
      // highlight state on map with glow
      svg.selectAll("path.state")
        .classed("pinned", d => +d.id === pinned)
        .classed("compared", false);
    }else{
      pTitle.text("Select a state");
      pMonth.text("â€”");
      pMetric.text("â€”");
      pinHint.text("Not pinned");
      kpis.html("");
      svg.selectAll("path.state").classed("pinned", false);
    }
    // ðŸ”´ KEY FIX: Update insights charts when pinned state changes
    updateTrendChartBelow();
    renderInsights();
  };

  // Toggle compare mode
  window.toggleCompareMode = function(){
    isCompareMode = !isCompareMode;
    if(compareBtn){
      if(isCompareMode){
        compareBtn.style.background = "rgba(255,214,87,.3)";
        compareBtn.style.borderColor = "rgba(255,214,87,.7)";
        compareBtn.style.color = "var(--accent-mid)";
        compareBtn.style.opacity = "1";
      }else{
        compareBtn.style.background = "rgba(88,166,255,.2)";
        compareBtn.style.borderColor = "rgba(88,166,255,.4)";
        compareBtn.style.color = "#58a6ff";
        compareBtn.style.opacity = "0.6";
      }
    }
    comparedStates = [];
    updateCompareBtn();
    svg.selectAll("path.state").classed("compared", false);
    
    // Hide comparison card when exiting compare mode
    const compCard = document.getElementById("comparisonCard");
    if(compCard) compCard.style.display = "none";
    
    if(!isCompareMode && pinned != null){
      setPanel(months[+monthRange.node().value], pinned, true);
      if(hintEl) hintEl.textContent = "Hover = preview â€¢ Click = pin panel";
    }else if(isCompareMode){
      // Show hint when entering compare mode
      pTitle.text("Select states to compare");
      pMonth.text("(up to 3)");
      kpis.html("");
      if(hintEl) hintEl.textContent = "Click states to compare (up to 3) â€¢ ESC to exit";
    }else{
      // Reset hint
      if(hintEl) hintEl.textContent = "Hover = preview â€¢ Click = pin panel";
    }
    
    // ðŸ”´ KEY FIX: Update insights charts when exiting/entering compare mode
    updateTrendChartBelow();
    renderInsights();
  };

  // Add state to compare
  window.addStateToCompare = function(fips){
    if(!isCompareMode) return;
    const id = +fips;
    const idx = comparedStates.findIndex(s => s === id);
    if(idx > -1){
      comparedStates.splice(idx, 1);
    }else if(comparedStates.length < 3){
      comparedStates.push(id);
    }
    updateCompareBtn();
    renderComparison();
    
    // Re-render states to update colors
    const month = months[+monthRange.node().value];
    const metric = metricSel.node().value;
    const mode = scaleMode.node().value;
    const domain = getDomain(metric, month, mode);
    const scale = d3.scaleQuantile().domain(domain.length > 1 ? [domain[0], domain[1]] : [0,1]).range(d3.range(9).map(i=>ramp(i/8)));
    
    svg.selectAll("path.state")
      .transition().duration(150)
      .attr("fill", d => {
        const r = rec(month, +d.id);
        if(!r || !isFinite(r[metric])) return "#3d444d";
        
        const color = scale(r[metric]);
        
        // In compare mode, desaturate unselected states
        if(isCompareMode && comparedStates.length > 0 && !comparedStates.includes(+d.id)){
          const rgb = d3.rgb(color);
          const gray = (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114) * 0.6;
          return d3.rgb(gray * 0.7, gray * 0.72, gray * 0.75).toString();
        }
        return color;
      })
      .classed("compared", d => comparedStates.includes(+d.id));
    
    // ðŸ”´ KEY FIX: Update insights charts when compare selection changes
    updateTrendChartBelow();
    renderInsights();
  };

  function updateCompareBtn(){
    if(compareBtn) compareBtn.innerHTML = `ðŸ“Š Compare (${comparedStates.length})`;
  }

  function renderComparison(){
    let compCard = document.getElementById("comparisonCard");
    if(!compCard){
      compCard = document.createElement("div");
      compCard.id = "comparisonCard";
      compCard.style.cssText = `background:var(--card); border-radius:8px; padding:16px; margin-bottom:12px;
        border-left:4px solid var(--accent-mid);`;
      const sidebar = document.querySelector("aside.right");
      // Insert after Rankings card (which contains topList)
      const rankingsCard = document.querySelector("#topList").closest(".card");
      if(rankingsCard && rankingsCard.nextElementSibling){
        rankingsCard.parentElement.insertBefore(compCard, rankingsCard.nextElementSibling);
      }else{
        sidebar.appendChild(compCard);
      }
    }
    
    if(comparedStates.length === 0){
      compCard.style.display = "none";
      return;
    }
    
    compCard.style.display = "block";
    const month = months[+monthRange.node().value];
    const metric = metricSel.node().value;
    
    let html = `<div style="font-size:13px; font-weight:600; color:var(--accent-mid); margin-bottom:10px;">
                  Comparing ${comparedStates.length} state${comparedStates.length>1?"s":""}
                </div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px;">`;
    
    comparedStates.forEach(fips => {
      const r = rec(month, fips);
      const name = r?.abbr || "?";
      html += `<span style="background:rgba(255,214,87,.1); padding:4px 8px; border-radius:4px; font-size:11px; 
               border-left:2px solid var(--accent-mid); color:var(--text);">${name}</span>`;
    });
    
    html += `</div>
             <table style="width:100%; font-size:11px; border-collapse:collapse;">
             <tr style="border-bottom:1px solid var(--stroke); color:var(--muted);">
               <td style="padding:6px 0;">State</td>
               <td style="padding:6px 0; text-align:right;">${META[metric].label}</td>
               <td style="padding:6px 0; text-align:right;">Rate</td>
               <td style="padding:6px 0; text-align:right;">Clear</td>
             </tr>`;
    
    comparedStates.forEach(fips => {
      const r = rec(month, fips);
      if(r){
        const val = r[metric] || 0;
        const fmt = META[metric].fmt(val);
        const rate = (r.rate_per_100k || 0).toFixed(1);
        const clear = Math.round((r.clearances / r.offenses) * 100) || 0;
        html += `<tr style="border-bottom:1px solid rgba(255,255,255,.05);">
                 <td style="padding:6px 0; font-weight:600;">${r.abbr}</td>
                 <td style="padding:6px 0; text-align:right; color:var(--accent-high);">${fmt}</td>
                 <td style="padding:6px 0; text-align:right;">${rate}</td>
                 <td style="padding:6px 0; text-align:right;">${clear}%</td>
                </tr>`;
      }
    });
    
    html += `</table>`;
    
    // Add Radar comparison if 2-3 states selected
    if(comparedStates.length >= 2){
      html += `<div style="margin-top:16px; padding-top:12px; border-top:1px solid var(--stroke);">
                 <div style="font-size:11px; font-weight:600; color:var(--muted); margin-bottom:8px;">Profile Comparison</div>
                 <svg id="compRadar" width="100%" height="220" style="background:rgba(0,0,0,.15); border-radius:6px; overflow:visible;"></svg>
               </div>`;
    }
    
    compCard.innerHTML = html;
    
    // Render comparison radar if needed
    if(comparedStates.length >= 2){
      renderComparisonRadar(month);
    }
  }
  
  function renderComparisonRadar(month){
    const svg = d3.select('#compRadar');
    svg.selectAll('*').remove();
    
    const width = +svg.attr('width'), height = +svg.attr('height');
    const radius = Math.min(width, height) / 2 - 30;
    const center = {x: width / 2, y: height / 2};
    
    const colors = ['#ff7b72', '#58a6ff', '#ffd657'];
    const axes = ['Rate/100k', 'Trend â†‘', 'Clear', 'Firearm', 'Stranger'];
    const angleSlice = (Math.PI * 2) / axes.length;
    
    const g = svg.append('g').attr('transform', `translate(${center.x},${center.y})`);
    
    // Draw concentric circles (grid)
    for(let i = 1; i <= 3; i++){
      const r = (radius / 3) * i;
      g.append('circle')
        .attr('r', r)
        .attr('fill', 'none')
        .attr('stroke', 'rgba(88,166,255,.1)')
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '2 2');
    }
    
    // Draw axes
    axes.forEach((axis, i) => {
      const angle = angleSlice * i - Math.PI / 2;
      const x = Math.cos(angle) * radius;
      const y = Math.sin(angle) * radius;
      
      g.append('line')
        .attr('x1', 0).attr('y1', 0)
        .attr('x2', x).attr('y2', y)
        .attr('stroke', 'rgba(88,166,255,.15)')
        .attr('stroke-width', 1);
      
      // Axis labels (smaller font for comparison)
      const lx = Math.cos(angle) * (radius + 20);
      const ly = Math.sin(angle) * (radius + 20);
      g.append('text')
        .attr('x', lx).attr('y', ly)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('font-size', '9px')
        .attr('fill', 'rgba(139,148,158,.6)')
        .text(axis);
    });
    
    // Draw polygons and nodes for each state
    comparedStates.forEach((fips, stateIdx) => {
      const scores = calculateZScores(month, fips);
      if(!scores) return;
      
      const normalize = (z) => Math.max(0, Math.min(1, (z + 2) / 4));
      const values = [
        normalize(scores.rateZ),
        normalize(scores.trendZ),
        1 - scores.clearInv,
        scores.firearm,
        scores.stranger
      ];
      
      // Draw polygon
      const points = values.map((val, i) => {
        const angle = angleSlice * i - Math.PI / 2;
        const r = val * radius;
        return [Math.cos(angle) * r, Math.sin(angle) * r];
      });
      
      const pathD = points.map((p, i) => (i === 0 ? `M ${p[0]},${p[1]}` : `L ${p[0]},${p[1]}`)).join(' ') + ' Z';
      
      g.append('path')
        .attr('d', pathD)
        .attr('fill', colors[stateIdx])
        .attr('fill-opacity', 0.15)
        .attr('stroke', colors[stateIdx])
        .attr('stroke-width', 1.5);
      
      // Draw nodes
      points.forEach((p, i) => {
        g.append('circle')
          .attr('cx', p[0]).attr('cy', p[1])
          .attr('r', 3)
          .attr('fill', colors[stateIdx])
          .attr('stroke', 'var(--bg)')
          .attr('stroke-width', 1);
      });
    });
    
    // Legend
    comparedStates.forEach((fips, i) => {
      const r = rec(month, fips);
      const abbr = r?.abbr || '?';
      const name = r?.name?.substring(0, 8) || '?';
      
      const legendG = g.append('g').attr('transform', `translate(${center.x - 50 + i * 45}, ${center.y + radius + 28})`);
      legendG.append('circle').attr('r', 4).attr('fill', colors[i]);
      legendG.append('text')
        .attr('x', 10).attr('y', 4)
        .attr('font-size', '10px')
        .attr('font-weight', '600')
        .attr('fill', 'var(--text)')
        .text(abbr);
    });
  }

  metricSel.on("change", render);
  monthRange.on("input", render);
  scaleMode.on("change", render);

  render();

  // ---------- Additional charts: Time series (US totals) ----------
  function aggregateUSMonth(raw){
    const byMonth = d3.rollup(raw, v => ({
      incidents: d3.sum(v, d=>d.offenses),
      clearances: d3.sum(v, d=>d.clearances),
      population: d3.sum(v, d=>d.population) || 330000000
    }), d=>d.month);
    const arr = Array.from(byMonth, ([month, vals])=>({month, incidents: vals.incidents, clearances: vals.clearances, population: vals.population}));
    arr.sort((a,b)=>a.month.localeCompare(b.month));
    return arr;
  }

  // ---------- NEW MODULAR INSIGHTS CHARTS ----------
  // TREND CHART - Below map version (reusing renderTimeSeries logic)
  function updateTrendChartBelow(){
    const containerEl = document.getElementById("trendChartContainer");
    if (!containerEl) {
      console.warn("[Trend] Container not found");
      return;
    }
    
    // Use scheduleRender for robust rendering
    scheduleRender(containerEl, (el, w, h) => {
      renderTrendChartContent(el, w);
    });
  }

  // Actual trend chart rendering (called by scheduleRender)
  function renderTrendChartContent(containerEl, forcedWidth) {
    const container = d3.select(containerEl);
    container.html(""); // Clear previous
    
    // Get pinned state data if available
    let selectedStateData = null;
    if(pinned != null){
      selectedStateData = months.map(month => {
        const r = rec(month, pinned);
        return r ? {month, offenses: r.offenses, clearances: r.clearances, rate: r.rate_per_100k, clearRate: r.clearance_rate} : null;
      }).filter(d => d != null);
    }

    const usData = aggregateUSMonth(raw);
    
    // Pre-calculate US clearance rates
    const usClearRates = months.map(month => {
      const monthData = raw.filter(r => r.month === month);
      const totalClearances = d3.sum(monthData, d => d.clearances);
      const totalOffenses = d3.sum(monthData, d => d.offenses);
      return {month, clearRate: totalOffenses ? totalClearances / totalOffenses : 0};
    });
    
    usData.forEach((d, i) => {
      d.clearRate = usClearRates[i]?.clearRate || 0;
    });

    let containerWidth = forcedWidth || containerEl.offsetWidth;
    if (!containerWidth || containerWidth === 0) {
      const parent = containerEl.parentElement;
      containerWidth = parent ? parent.offsetWidth - 40 : 700;
    }
    containerWidth = Math.max(400, containerWidth);
    
    const margin = {l: 50, t: 20, r: 20, b: 40};
    const w = Math.max(500, containerWidth - margin.l - margin.r);
    const h = 260;

    const svg = container.append("svg")
      .attr("width", containerWidth)
      .attr("height", h + margin.t + margin.b)
      .style("background", "transparent");

    const g = svg.append("g").attr("transform", `translate(${margin.l},${margin.t})`);

    const parse = d3.timeParse('%Y-%m');
    usData.forEach(d=>d.dt = parse(d.month));
    if(selectedStateData) selectedStateData.forEach(d=>d.dt = parse(d.month));

    // Scale
    const maxRate = Math.max(
      d3.max(usData, d => d.incidents / (d.population || 1) * 100000) || 0,
      selectedStateData ? d3.max(selectedStateData, d => d.rate) : 0
    );
    
    const maxClearRate = 1;
    const x = d3.scaleTime().domain(d3.extent(usData,d=>d.dt)).range([0,w]);
    const yOffense = d3.scaleLinear().domain([0, maxRate]).nice().range([h,0]);
    const yClear = d3.scaleLinear().domain([0, maxClearRate]).range([h,0]);

    const lineStateOffense = d3.line().x(d=>x(d.dt)).y(d=>yOffense(d.rate)).curve(d3.curveMonotoneX);
    const lineUSOffense = d3.line().x(d=>x(d.dt)).y(d=>yOffense((d.incidents / (d.population || 1)) * 100000)).curve(d3.curveMonotoneX);
    const lineStateClear = d3.line().x(d=>x(d.dt)).y(d=>yClear(d.clearRate)).curve(d3.curveMonotoneX);
    const lineUSClear = d3.line().x(d=>x(d.dt)).y(d=>yClear(d.clearRate)).curve(d3.curveMonotoneX);

    // Grid
    g.selectAll('.grid-y').data(yOffense.ticks(3)).enter()
      .append('line')
      .attr('class','grid-y')
      .attr('x1',0).attr('x2',w)
      .attr('y1',d=>yOffense(d)).attr('y2',d=>yOffense(d))
      .attr('stroke','rgba(88,166,255,.05)').attr('stroke-width',1).attr('stroke-dasharray','2 2');

    // Lines: US (dashed)
    g.append('path').datum(usData).attr('d', lineUSOffense).attr('fill','none').attr('stroke','#8b949e').attr('stroke-width',2).attr('opacity',0.6).style('stroke-dasharray','4 2');
    g.append('path').datum(usData).attr('d', lineUSClear).attr('fill','none').attr('stroke','#10b981').attr('stroke-width',2).attr('opacity',0.4).style('stroke-dasharray','4 2');
    
    // Lines: Selected state (solid)
    if(selectedStateData){
      g.append('path').datum(selectedStateData).attr('d', lineStateOffense).attr('fill','none').attr('stroke','#ff7b72').attr('stroke-width',2.5).attr('opacity',0.95);
      g.append('path').datum(selectedStateData).attr('d', lineStateClear).attr('fill','none').attr('stroke','#10b981').attr('stroke-width',2.5).attr('opacity',0.95);
    }

    // Axes
    const xAxis = d3.axisBottom(x).ticks(4).tickFormat(d3.timeFormat('%Y-%m'));
    const yAxis = d3.axisLeft(yOffense).ticks(4).tickFormat(d3.format(','));
    g.append('g').attr('transform',`translate(0,${h})`).call(xAxis)
      .selectAll('text').style('font-size','11px').style('fill','rgba(139,148,158,.7)');
    g.append('g').call(yAxis)
      .selectAll('text').style('font-size','11px').style('fill','rgba(139,148,158,.7)');

    // Axis lines
    g.append('line').attr('x1',-5).attr('x2',w).attr('y1',h).attr('y2',h).attr('stroke','rgba(88,166,255,.15)').attr('stroke-width',1);
    g.append('line').attr('x1',0).attr('x2',0).attr('y1',0).attr('y2',h).attr('stroke','rgba(88,166,255,.15)').attr('stroke-width',1);

    // Legend
    const legend = svg.append('g').attr('transform',`translate(${margin.l},8)`);
    let legendY = 0;
    if(selectedStateData){
      legend.append('circle').attr('r',3).attr('fill','#ff7b72').attr('cy', legendY);
      legend.append('text').attr('x',10).attr('y',legendY+4).text('Selected State').style('font-size','11px').style('fill','rgba(139,148,158,.85)').style('font-weight','500');
      legendY += 16;
    }
    legend.append('circle').attr('r',3).attr('fill','#8b949e').attr('cy', legendY);
    legend.append('text').attr('x',10).attr('y',legendY+4).text('US Average').style('font-size','11px').style('fill','rgba(139,148,158,.85)').style('font-weight','500');
  }
  // ---------- End MODULAR INSIGHTS CHARTS ----------
  
  function renderTimeSeries(){
    // Get pinned state data if available
    let selectedStateData = null;
    if(pinned != null){
      selectedStateData = months.map(month => {
        const r = rec(month, pinned);
        return r ? {month, offenses: r.offenses, clearances: r.clearances, rate: r.rate_per_100k, clearRate: r.clearance_rate} : null;
      }).filter(d => d != null);
    }

    const usData = aggregateUSMonth(raw);
    
    // Pre-calculate US clearance rates
    const usClearRates = months.map(month => {
      const monthData = raw.filter(r => r.month === month);
      const totalClearances = d3.sum(monthData, d => d.clearances);
      const totalOffenses = d3.sum(monthData, d => d.offenses);
      return {month, clearRate: totalOffenses ? totalClearances / totalOffenses : 0};
    });
    
    usData.forEach((d, i) => {
      d.clearRate = usClearRates[i]?.clearRate || 0;
    });

    const svgTs = d3.select('#tsSvg');
    svgTs.selectAll('*').remove();
    const w = +svgTs.attr('width') - 48, h = +svgTs.attr('height') - 32;
    const g = svgTs.append('g').attr('transform','translate(40,8)');

    const parse = d3.timeParse('%Y-%m');
    usData.forEach(d=>d.dt = parse(d.month));
    if(selectedStateData) selectedStateData.forEach(d=>d.dt = parse(d.month));

    // Scale: use rate per 100k for better comparison
    const maxRate = Math.max(
      d3.max(usData, d => d.incidents / (d.population || 1) * 100000) || 0,
      selectedStateData ? d3.max(selectedStateData, d => d.rate) : 0
    );
    
    const maxClearRate = 1; // 0-100% for clearance rate
    const x = d3.scaleTime().domain(d3.extent(usData,d=>d.dt)).range([0,w]);
    const yOffense = d3.scaleLinear().domain([0, maxRate]).nice().range([h,0]);
    const yClear = d3.scaleLinear().domain([0, maxClearRate]).range([h,0]);

    const lineStateOffense = d3.line().x(d=>x(d.dt)).y(d=>yOffense(d.rate)).curve(d3.curveMonotoneX);
    const lineUSOffense = d3.line().x(d=>x(d.dt)).y(d=>yOffense((d.incidents / (d.population || 1)) * 100000)).curve(d3.curveMonotoneX);
    const lineStateClear = d3.line().x(d=>x(d.dt)).y(d=>yClear(d.clearRate)).curve(d3.curveMonotoneX);
    const lineUSClear = d3.line().x(d=>x(d.dt)).y(d=>yClear(d.clearRate)).curve(d3.curveMonotoneX);

    // Grid
    g.selectAll('.grid-y').data(yOffense.ticks(3)).enter()
      .append('line')
      .attr('class','grid-y')
      .attr('x1',0).attr('x2',w)
      .attr('y1',d=>yOffense(d)).attr('y2',d=>yOffense(d))
      .attr('stroke','rgba(88,166,255,.05)').attr('stroke-width',1).attr('stroke-dasharray','2 2');

    // Lines: US (dashed)
    g.append('path').datum(usData).attr('d', lineUSOffense).attr('fill','none').attr('stroke','#8b949e').attr('stroke-width',2).attr('opacity',0.6).style('stroke-dasharray','4 2');
    g.append('path').datum(usData).attr('d', lineUSClear).attr('fill','none').attr('stroke','#10b981').attr('stroke-width',2).attr('opacity',0.4).style('stroke-dasharray','4 2');
    
    // Lines: Selected state (solid)
    if(selectedStateData){
      g.append('path').datum(selectedStateData).attr('d', lineStateOffense).attr('fill','none').attr('stroke','#ff7b72').attr('stroke-width',2.5).attr('opacity',0.95);
      g.append('path').datum(selectedStateData).attr('d', lineStateClear).attr('fill','none').attr('stroke','#10b981').attr('stroke-width',2.5).attr('opacity',0.95);
    }

    // Axes
    const xAxis = d3.axisBottom(x).ticks(3).tickFormat(d3.timeFormat('%Y-%m'));
    const yAxis = d3.axisLeft(yOffense).ticks(3).tickFormat(d3.format(','));
    g.append('g').attr('transform',`translate(0,${h})`).call(xAxis)
      .selectAll('text').style('font-size','10px').style('fill','rgba(139,148,158,.7)').style('font-weight','500');
    g.append('g').call(yAxis)
      .selectAll('text').style('font-size','10px').style('fill','rgba(139,148,158,.7)').style('font-weight','500');

    // Axis lines
    g.append('line').attr('x1',-5).attr('x2',w).attr('y1',h).attr('y2',h).attr('stroke','rgba(88,166,255,.15)').attr('stroke-width',1);
    g.append('line').attr('x1',0).attr('x2',0).attr('y1',0).attr('y2',h).attr('stroke','rgba(88,166,255,.15)').attr('stroke-width',1);

    // Legend
    const legend = svgTs.append('g').attr('transform','translate(10,10)');
    let legendY = 0;
    if(selectedStateData){
      legend.append('circle').attr('r',3).attr('fill','#ff7b72').attr('cy', legendY);
      legend.append('text').attr('x',10).attr('y',legendY+4).text('Selected (solid)').style('font-size','11px').style('fill','rgba(139,148,158,.85)').style('font-weight','500');
      legendY += 16;
    }
    legend.append('circle').attr('r',3).attr('fill','#8b949e').attr('cy', legendY);
    legend.append('text').attr('x',10).attr('y',legendY+4).text('US Avg (dashed)').style('font-size','11px').style('fill','rgba(139,148,158,.85)').style('font-weight','500');
    legendY += 16;
    legend.append('circle').attr('r',3).attr('fill','#10b981').attr('cy', legendY);
    legend.append('text').attr('x',10).attr('y',legendY+4).text('Clearance Rate').style('font-size','11px').style('fill','rgba(139,148,158,.85)').style('font-weight','500');
  }

  // ---------- Demographics (sample static data from user) ----------
  const offenderAge = [
    {age:'20-29',v:804232},{age:'30-39',v:780177},{age:'40-49',v:433988},{age:'10-19',v:379813},
    {age:'Unknown',v:329673},{age:'50-59',v:237879},{age:'60-69',v:101324},{age:'70-79',v:23753},
    {age:'0-9',v:5057},{age:'80-89',v:5002},{age:'90-Older',v:2193}
  ];
  const offenderSex = [
    {sex:'Male',v:2265464},{sex:'Female',v:696299},{sex:'Unknown',v:137568},{sex:'Not Specified',v:301008}
  ];

  function renderAgeChart(){
    const svgA = d3.select('#ageSvg'); svgA.selectAll('*').remove();
    const margin = {l:70,t:8,r:8,b:20};
    const w = +svgA.attr('width') - margin.l - margin.r;
    const h = +svgA.attr('height') - margin.t - margin.b;
    const g = svgA.append('g').attr('transform',`translate(${margin.l},${margin.t})`);

    const sorted = [...offenderAge].sort((a,b)=>b.v-a.v);
    const x = d3.scaleLinear().domain([0,d3.max(sorted,d=>d.v)]).range([0,w]);
    const y = d3.scaleBand().domain(sorted.map(d=>d.age)).range([0,h]).padding(0.25);

    const colorScale = d3.scaleLinear()
      .domain([0, d3.max(sorted,d=>d.v)])
      .range(['#58a6ff', '#ff7b72']);

    g.selectAll('rect').data(sorted).enter().append('rect')
      .attr('y',d=>y(d.age)).attr('height',y.bandwidth())
      .attr('x',0).attr('width',d=>x(d.v)).attr('fill',d=>colorScale(d.v)).attr('rx','3')
      .style('filter','drop-shadow(0 1px 3px rgba(88,166,255,.15))');

    // value labels
    g.selectAll('.label').data(sorted).enter().append('text')
      .attr('class','label')
      .attr('y',d=>y(d.age)+y.bandwidth()/2)
      .attr('x',d=>x(d.v)+6)
      .attr('dy','0.35em')
      .text(d=>d3.format('.0s')(d.v))
      .style('font-size','10px').style('fill','rgba(139,148,158,.8)').style('font-weight','600');

    g.append('g').call(d3.axisLeft(y)).selectAll('text').style('font-size','11px').style('fill','rgba(139,148,158,.8)').style('font-weight','500');
    g.append('g').attr('transform',`translate(0,${h})`).call(d3.axisBottom(x).ticks(3).tickFormat(d3.format('.0s')))
      .selectAll('text').style('font-size','10px').style('fill','rgba(139,148,158,.7)').style('font-weight','500');
  }

  function renderSexChart(){
    const svgS = d3.select('#sexSvg'); svgS.selectAll('*').remove();
    const w = +svgS.attr('width'), h = +svgS.attr('height');
    const radius = Math.min(w,h)/2 - 18;
    const g = svgS.append('g').attr('transform',`translate(${w/2-50},${h/2})`);

    const pie = d3.pie().value(d=>d.v)(offenderSex);
    const arc = d3.arc().innerRadius(radius*0.55).outerRadius(radius);
    const color = d3.scaleOrdinal()
      .domain(offenderSex.map(d=>d.sex))
      .range(['#58a6ff','#ffd657','#ff7b72','#7ee787']);

    g.selectAll('path').data(pie).enter().append('path')
      .attr('d',arc)
      .attr('fill',d=>color(d.data.sex))
      .attr('stroke','rgba(13,17,23,.8)')
      .attr('stroke-width',2)
      .style('filter','drop-shadow(0 2px 6px rgba(0,0,0,.25))')
      .style('transition','all 0.2s ease');

    // legend
    const lg = svgS.append('g').attr('transform','translate(8,8)');
    offenderSex.forEach((s,i)=>{
      const total = d3.sum(offenderSex, d=>d.v);
      const pct = ((s.v / total)*100).toFixed(0);
      lg.append('circle').attr('r',3).attr('cy',i*16).attr('cx',3).attr('fill',color(s.sex));
      lg.append('text').attr('x',14).attr('y',i*16+4)
        .text(`${s.sex}: ${pct}%`)
        .style('font-size','11px').style('fill','rgba(139,148,158,.85)').style('font-weight','600');
    });
  }
  // ---------- NEW MODULAR INSIGHTS CHARTS ----------
  // 1. SCATTER CHART - Clearance Rate vs Offenses (colored by firearm share)
  function initScatterChart(){
    const container = d3.select("#scatterChartContainer");
    container.html("");
    
    // Get actual container width - with fallback to body width
    const containerEl = document.getElementById("scatterChartContainer");
    if (!containerEl) {
      console.error("[Scatter] Container #scatterChartContainer not found");
      return null;
    }
    
    // Get computed width
    let containerWidth = containerEl.offsetWidth;
    if (!containerWidth || containerWidth === 0) {
      // Fallback: get parent width
      const parent = containerEl.parentElement;
      containerWidth = parent ? parent.offsetWidth - 40 : 700; // 40px for padding
    }
    containerWidth = Math.max(300, containerWidth);
    
    const margin = {l: 50, t: 20, r: 20, b: 40};
    const w = Math.max(300, containerWidth - margin.l - margin.r);
    const h = 280;
    
    const svg = container.append("svg")
      .attr("width", containerWidth)
      .attr("height", h + margin.t + margin.b)
      .style("background", "transparent");
    
    const g = svg.append("g").attr("transform", `translate(${margin.l},${margin.t})`);
    
    // Add gridlines
    g.append("g").attr("class", "grid-x")
      .selectAll("line").data(d3.ticks(0, 1, 5)).enter()
      .append("line")
      .attr("x1", 0).attr("x2", w)
      .attr("y1", (d, i) => (i / 4) * h).attr("y2", (d, i) => (i / 4) * h)
      .attr("stroke", "rgba(88,166,255,.05)").attr("stroke-width", 1);
    
    console.log("[Scatter] Chart initialized: width=", containerWidth, "w=", w, "h=", h);
    return {svg, g, margin, w, h, containerWidth};
  }

  function updateScatterChart(){
    const containerEl = document.getElementById("scatterChartContainer");
    if (!containerEl) {
      console.warn("[Scatter] Container not found");
      return;
    }
    
    // Use scheduleRender for robust rendering
    scheduleRender(containerEl, (el, w, h) => {
      renderScatterChartContent(el, w, h);
    });
  }

  // Actual scatter chart rendering (called by scheduleRender)
  function renderScatterChartContent(containerEl, forcedW, forcedH) {
    console.log("[Scatter] Rendering scatter chart content...");
    const current_month = months[+monthRange.node().value];
    if(!current_month) {
      console.log("[Scatter] No month selected");
      return;
    }
    
    // Get all states data
    const stateData = states.map(s => {
      const r = rec(current_month, +s.id);
      if(!r || !r.offenses || !isFinite(r.rate_per_100k)) return null;
      
      return {
        fips: +s.id,
        name: r.name,
        abbr: r.abbr,
        rate: r.rate_per_100k,
        offenses: r.offenses,
        clearRate: Math.min(1, Math.max(0, (r.clearances / r.offenses) || 0)),
        firearm: 0.2 + Math.random() * 0.3, // Synthetic firearm share 20-50%
        isPinned: pinned === +s.id,
        isCompared: comparedStates.includes(+s.id)
      };
    }).filter(d => d != null);
    
    console.log("[Scatter] Data points:", stateData.length);
    
    if(stateData.length === 0){
      d3.select(containerEl).html(
        '<div style="text-align:center; color:rgba(139,148,158,.7); padding:60px 20px;">No data available for selected month</div>'
      );
      return;
    }

    // Calculate sizes
    let containerWidth = forcedW || containerEl.offsetWidth;
    if (!containerWidth || containerWidth === 0) {
      const parent = containerEl.parentElement;
      containerWidth = parent ? parent.offsetWidth - 40 : 700;
    }
    containerWidth = Math.max(300, containerWidth);
    
    const margin = {l: 50, t: 20, r: 20, b: 40};
    const w = Math.max(300, containerWidth - margin.l - margin.r);
    const h = forcedH || 280;
    
    // Create SVG directly
    const container = d3.select(containerEl);
    container.html(""); // Clear previous
    
    const svg = container.append("svg")
      .attr("width", containerWidth)
      .attr("height", h + margin.t + margin.b)
      .style("background", "transparent");
    
    const g = svg.append("g").attr("transform", `translate(${margin.l},${margin.t})`);
    
    // Add gridlines
    g.append("g").attr("class", "grid-x")
      .selectAll("line").data(d3.ticks(0, 1, 5)).enter()
      .append("line")
      .attr("x1", 0).attr("x2", w)
      .attr("y1", (d, i) => (i / 4) * h).attr("y2", (d, i) => (i / 4) * h)
      .attr("stroke", "rgba(88,166,255,.05)").attr("stroke-width", 1);
    
    console.log("[Scatter] Chart rendering: width=", containerWidth, "w=", w, "h=", h);
    
    // Scales
    const xExtent = d3.extent(stateData, d => d.rate);
    console.log("[Scatter] X extent:", xExtent);
    
    const xScale = d3.scaleLinear().domain([0, xExtent[1] * 1.1]).range([0, w]);
    const yScale = d3.scaleLinear().domain([0, 1]).range([h, 0]);
    const colorScale = d3.scaleLinear().domain([0.2, 0.5]).range(["#58a6ff", "#ff7b72"]);
    
    const xAxis = d3.axisBottom(xScale).ticks(5).tickFormat(d3.format(".0f"));
    const yAxis = d3.axisLeft(yScale).ticks(4).tickFormat(d3.format(".0%"));
    
    // Render points
    g.selectAll("circle.scatter").data(stateData, d => d.fips).join(
      enter => enter.append("circle").attr("class", "scatter")
        .attr("cx", d => xScale(d.rate))
        .attr("cy", d => yScale(d.clearRate))
        .attr("r", d => d.isPinned ? 8 : 5)
        .attr("fill", d => colorScale(d.firearm))
        .attr("opacity", d => d.isPinned ? 1 : (d.isCompared ? 0.8 : 0.5))
        .attr("stroke", d => d.isPinned ? "#ffd657" : (d.isCompared ? "#ffd657" : "none"))
        .attr("stroke-width", 2)
        .style("filter", d => d.isPinned || d.isCompared ? "drop-shadow(0 0 8px rgba(255,214,87,.6))" : "none")
        .style("cursor", "pointer"),
      update => update
        .attr("r", d => d.isPinned ? 8 : 5)
        .attr("opacity", d => d.isPinned ? 1 : (d.isCompared ? 0.8 : 0.5))
        .attr("stroke", d => d.isPinned ? "#ffd657" : (d.isCompared ? "#ffd657" : "none"))
        .style("filter", d => d.isPinned || d.isCompared ? "drop-shadow(0 0 8px rgba(255,214,87,.6))" : "none")
    )
    .on("mouseover", function(event, d){
      d3.select(this).transition().duration(100).attr("r", 8).attr("opacity", 1);
      tooltip.style("opacity", 1)
        .html(`<div><strong>${d.name} (${d.abbr})</strong></div>
               <div class="muted">Offense Rate: ${d.rate.toFixed(1)} per 100k</div>
               <div class="muted">Clearance Rate: ${(d.clearRate * 100).toFixed(1)}%</div>
               <div class="muted">Total Offenses: ${d.offenses}</div>`);
    })
    .on("mouseout", function(event, d){
      d3.select(this).transition().duration(100).attr("r", d => d.isPinned ? 8 : 5).attr("opacity", d => d.isPinned ? 1 : (d.isCompared ? 0.8 : 0.5));
      tooltip.style("opacity", 0);
    })
    .on("click", function(event, d){
      pinState(d.fips, d.isPinned);
      render();
    });
    
    // Axes
    g.append("g").attr("transform", `translate(0,${h})`)
      .call(xAxis).selectAll("text").style("font-size", "11px").style("fill", "rgba(139,148,158,.7)");
    g.append("g").call(yAxis).selectAll("text").style("font-size", "11px").style("fill", "rgba(139,148,158,.7)");
    
    // Axis labels
    svg.append("text").attr("x", margin.l + w / 2).attr("y", h + margin.t + margin.b - 5)
      .attr("text-anchor", "middle").attr("font-size", "12px").attr("fill", "rgba(139,148,158,.7)")
      .text("Offense Rate (per 100,000)");
    svg.append("text").attr("transform", "rotate(-90)")
      .attr("x", -(margin.t + h / 2)).attr("y", 12)
      .attr("text-anchor", "middle").attr("font-size", "12px").attr("fill", "rgba(139,148,158,.7)")
      .text("Clearance Rate");
  }

  // 2. HEATMAP CHART - Location Ã— Weapon for selected state
  function updateHeatmapChart(){
    const containerEl = document.getElementById("heatmapChartContainer");
    if (!containerEl) {
      console.warn("[Heatmap] Container not found");
      return;
    }
    
    if(pinned == null){
      d3.select(containerEl).html(
        '<div style="text-align:center; color:rgba(139,148,158,.7); padding:80px 20px; font-size:14px;">ðŸ“Œ Select a state to view Location Ã— Weapon breakdown</div>'
      );
      return;
    }
    
    // Use scheduleRender for robust rendering
    scheduleRender(containerEl, (el, w, h) => {
      renderHeatmapChartContent(el, w, h);
    });
  }

  // Actual heatmap chart rendering (called by scheduleRender)
  function renderHeatmapChartContent(containerEl, forcedW, forcedH) {
    console.log("[Heatmap] Rendering heatmap chart content...");
    if(pinned == null) return;
    
    const container = d3.select(containerEl);
    container.html(""); // Clear previous
      let containerWidth = containerEl.offsetWidth;
    if (!containerWidth || containerWidth === 0) {
      const parent = containerEl.parentElement;
      containerWidth = parent ? parent.offsetWidth - 40 : 700;
    }
    containerWidth = Math.max(300, containerWidth);
    container.html("");
    
    // Generate synthetic Location Ã— Weapon matrix
    const locations = ["Street", "Residence", "Parking Lot", "School", "Bar"];
    const weapons = ["Firearm", "Knife", "Hands/Fists", "Blunt Object", "Other"];
    
    // Generate correlated data
    const matrix = [];
    locations.forEach((loc, i) => {
      weapons.forEach((wep, j) => {
        let value = Math.floor(Math.random() * 15) + 5;
        if(wep === "Firearm" && loc !== "Residence") value += Math.floor(Math.random() * 20);
        if(loc === "Street" && wep === "Firearm") value += 30;
        matrix.push({location: loc, weapon: wep, value});
      });
    });
    
    const cellSize = 40;
    const margin = {l: 100, t: 30, r: 20, b: 20};
    const width = Math.max(400, containerWidth - margin.l - margin.r);
    const height = weapons.length * cellSize + margin.t + margin.b;
    
    const svg = container.append("svg")
      .attr("width", containerWidth)
      .attr("height", height)
      .style("background", "transparent");
    
    const g = svg.append("g").attr("transform", `translate(${margin.l},${margin.t})`);
    
    const colorScale = d3.scaleLinear()
      .domain([0, d3.max(matrix, d => d.value)])
      .range(["rgba(88,166,255,.2)", "#ff7b72"]);
    
    // Heatmap cells
    g.selectAll("rect.cell").data(matrix).enter()
      .append("rect").attr("class", "cell")
      .attr("x", (d, i) => (i % locations.length) * cellSize + 2)
      .attr("y", (d, i) => Math.floor(i / locations.length) * cellSize + 2)
      .attr("width", cellSize - 4).attr("height", cellSize - 4)
      .attr("fill", d => colorScale(d.value))
      .attr("rx", 4)
      .style("cursor", "pointer")
      .on("mouseover", function(event, d){
        d3.select(this).attr("stroke", "#ffd657").attr("stroke-width", 2);
        tooltip.style("opacity", 1)
          .html(`<div><strong>${d.location} + ${d.weapon}</strong></div>
                 <div class="muted">Count: ${d.value}</div>`);
      })
      .on("mouseout", function(){
        d3.select(this).attr("stroke", "none");
        tooltip.style("opacity", 0);
      });
    
    // Location labels (top)
    locations.forEach((loc, i) => {
      g.append("text")
        .attr("x", i * cellSize + cellSize / 2 + 2)
        .attr("y", -10)
        .attr("text-anchor", "middle")
        .attr("font-size", "11px")
        .attr("font-weight", "600")
        .attr("fill", "#58a6ff")
        .text(loc);
    });
    
    // Weapon labels (left)
    weapons.forEach((wep, i) => {
      g.append("text")
        .attr("x", -10)
        .attr("y", i * cellSize + cellSize / 2 + 5)
        .attr("text-anchor", "end")
        .attr("font-size", "11px")
        .attr("font-weight", "600")
        .attr("fill", "#58a6ff")
        .text(wep);
    });
  }

  // 3. STACKED COMPOSITION CHART - Weapon types
  function updateStackedChart(){
    const containerEl = document.getElementById("stackedChartContainer");
    if (!containerEl) {
      console.warn("[Stacked] Container not found");
      return;
    }
    
    const current_month = months[+monthRange.node().value];
    if(!current_month) {
      console.log("[Stacked] No month selected");
      return;
    }
    
    if(pinned == null){
      d3.select(containerEl).html(
        '<div style="text-align:center; color:rgba(139,148,158,.7); padding:60px 20px;">ðŸ“Œ Select a state to compare</div>'
      );
      return;
    }
    
    // Use scheduleRender for robust rendering
    scheduleRender(containerEl, (el, w, h) => {
      renderStackedChartContent(el, w, h);
    });
  }

  // Actual stacked chart rendering (called by scheduleRender)
  function renderStackedChartContent(containerEl, forcedW, forcedH) {
    console.log("[Stacked] Rendering stacked chart content...");
    if(pinned == null) return;
    
    const current_month = months[+monthRange.node().value];
    if(!current_month) return;
    
    const container = d3.select(containerEl);
    container.html(""); // Clear previous
    
    let containerWidth = forcedW || containerEl.offsetWidth;
    if (!containerWidth || containerWidth === 0) {
      const parent = containerEl.parentElement;
      containerWidth = parent ? parent.offsetWidth - 40 : 700;
    }
    containerWidth = Math.max(300, containerWidth);
    
    const margin = {l: 50, t: 20, r: 80, b: 40};
    const w = Math.max(300, containerWidth - margin.l - margin.r);
    const h = forcedH || 160;
    
    const svg = container.append("svg")
      .attr("width", containerWidth)
      .attr("height", h + margin.t + margin.b)
      .style("background", "transparent");
    
    const g = svg.append("g").attr("transform", `translate(${margin.l},${margin.t})`);
    
    // Scales
    const xScale = d3.scaleBand().domain(["Pinned State", "US Average"]).range([0, w]).padding(0.3);
    const yScale = d3.scaleLinear().domain([0, 1]).range([h, 0]);
    
    const colors = {
      "Firearm": "#ff7b72",
      "Knife": "#ffa198",
      "Hands/Fists": "#f0883e",
      "Blunt Object": "#ffd657",
      "Other": "#8b949e"
    };
    
    // Stack data
    const stackData = [
      {category: "Pinned State", values: weapons.map(w => ({weapon: w.weapon, pct: w.pinnedPct}))},
      {category: "US Average", values: weapons.map(w => ({weapon: w.weapon, pct: w.usPct}))}
    ];
    
    let yOffset = 0;
    stackData.forEach((cat, i) => {
      let y = 0;
      cat.values.forEach(item => {
        const height = yScale(y) - yScale(y + item.pct);
        g.append("rect")
          .attr("x", xScale(cat.category))
          .attr("y", yScale(y + item.pct))
          .attr("width", xScale.bandwidth())
          .attr("height", height)
          .attr("fill", colors[item.weapon])
          .attr("stroke", "rgba(22,27,34,.4)")
          .attr("stroke-width", 1)
          .style("cursor", "pointer")
          .on("mouseover", function(){
            d3.select(this).attr("opacity", 0.8).attr("stroke", "#ffd657").attr("stroke-width", 2);
            tooltip.style("opacity", 1)
              .html(`<div><strong>${item.weapon}</strong></div>
                     <div class="muted">${cat.category}: ${(item.pct * 100).toFixed(1)}%</div>`);
          })
          .on("mouseout", function(){
            d3.select(this).attr("opacity", 1).attr("stroke", "rgba(22,27,34,.4)").attr("stroke-width", 1);
            tooltip.style("opacity", 0);
          });
        y += item.pct;
      });
    });
    
    // Axes
    g.append("g").attr("transform", `translate(0,${h})`)
      .call(d3.axisBottom(xScale)).selectAll("text").style("font-size", "12px").style("fill", "rgba(139,148,158,.8)");
    g.append("g").call(d3.axisLeft(yScale).ticks(5).tickFormat(d3.format(".0%")))
      .selectAll("text").style("font-size", "11px").style("fill", "rgba(139,148,158,.7)");
    
    // Legend
    const legend = svg.append("g").attr("transform", `translate(${margin.l + w + 20},${margin.t})`);
    weapons.forEach((w, i) => {
      legend.append("rect").attr("x", 0).attr("y", i * 18).attr("width", 12).attr("height", 12)
        .attr("fill", colors[w.weapon]).attr("rx", 2);
      legend.append("text").attr("x", 16).attr("y", i * 18 + 10)
        .attr("font-size", "11px").attr("fill", "rgba(139,148,158,.8)").text(w.weapon);
    });
  }

  // ---------- Sankey (from aggregated data) ----------
  function renderSankey(){
    const svgS = d3.select('#sankeySvg'); svgS.selectAll('*').remove();
    const width = +svgS.attr('width'), height = +svgS.attr('height');

    d3.json('data/sankey_us.json').then(data=>{
      if(!data || !data.nodes || !data.links) return;
      const sankeyGen = d3.sankey().nodeId(d=>d.id).nodeWidth(14).nodePadding(50).extent([[4,20],[width-4,height-10]]);
      const nodesIn = data.nodes.map(d => ({id: d.id}));
      const linksIn = data.links.map(d => ({source:d.source, target:d.target, value:+d.value}));
      const graph = sankeyGen({nodes: nodesIn, links: linksIn});

      // Color schemes: Location â†’ Weapon â†’ Offense
      const nodeColors = {
        'Street': '#58a6ff',      // blue
        'Residence': '#79c0ff',   // light blue
        'Vehicle': '#1f6feb',     // dark blue
        'Park': '#7ee787',        // green
        'School': '#ffd657',      // yellow
        'Other': '#8b949e',       // gray
        
        'Firearm': '#ff7b72',     // red
        'Knife': '#ffa198',       // light red
        'Hands': '#f0883e',       // orange
        
        'Aggravated Assault': '#ff7b72'
      };

      const linkColor = (d) => {
        const srcColor = nodeColors[d.source.id] || '#58a6ff';
        const c = d3.rgb(srcColor);
        return `rgba(${c.r},${c.g},${c.b},0.25)`;
      };

      const g = svgS.append('g');
      
      // Links with smooth effect
      g.append('g').selectAll('path').data(graph.links).enter().append('path')
        .attr('d', d3.sankeyLinkHorizontal())
        .attr('fill','none')
        .attr('stroke', linkColor)
        .attr('stroke-width', d=>Math.max(0.5, d.width))
        .attr('opacity',0.5)
        .style('filter','drop-shadow(0 1px 2px rgba(0,0,0,.15))')
        .style('transition','all 0.2s ease');

      // Nodes
      g.append('g').selectAll('rect').data(graph.nodes).enter().append('rect')
        .attr('x', d=>d.x0).attr('y', d=>d.y0).attr('width', d=>d.x1-d.x0).attr('height', d=>Math.max(1,d.y1-d.y0))
        .attr('fill', d=> nodeColors[d.id] || '#58a6ff')
        .attr('rx','4')
        .attr('stroke','rgba(88,166,255,.3)')
        .attr('stroke-width',1)
        .style('filter','drop-shadow(0 2px 6px rgba(0,0,0,.2))')
        .style('transition','all 0.2s ease')
        .style('cursor','pointer')
        .on('mouseover', function(){ d3.select(this).style('filter','drop-shadow(0 4px 12px rgba(88,166,255,.4))').attr('opacity',0.95); })
        .on('mouseout', function(){ d3.select(this).style('filter','drop-shadow(0 2px 6px rgba(0,0,0,.2))').attr('opacity',1); })
        .append('title').text(d=> `${d.id}\n${d3.format(',')(d.value)}`);

      // Labels
      g.append('g').selectAll('text').data(graph.nodes).enter().append('text')
        .attr('x', d=> d.x0 < width/2 ? d.x1 + 8 : d.x0 - 8)
        .attr('y', d=> (d.y1 + d.y0)/2)
        .attr('dy','0.35em')
        .attr('text-anchor', d=> d.x0 < width/2 ? 'start' : 'end')
        .text(d=>d.id)
        .style('font-size','11px')
        .style('font-weight','600')
        .style('fill','rgba(139,148,158,.9)')
        .style('pointer-events','none');

      // Column labels
      const levelWidth = width / 3;
      const colLabels = ['Location', 'Weapon', 'Offense'];
      const colX = [levelWidth/2, levelWidth + levelWidth/2, 2*levelWidth + levelWidth/2];
      
      colLabels.forEach((label, i) => {
        svgS.append('text')
          .attr('x', colX[i])
          .attr('y', 12)
          .attr('text-anchor', 'middle')
          .text(label.toUpperCase())
          .style('font-size', '9px')
          .style('font-weight', '700')
          .style('fill', '#58a6ff')
          .style('letter-spacing', '0.4px')
          .style('opacity', '0.8');
      });
    });
  }
  
  // ========== RESIZE OBSERVER FOR CHARTS ==========
  // Re-render charts when container sizes change
  function setupResizeObservers() {
    const containerIds = [
      "trendChartContainer",
      "scatterChartContainer",
      "heatmapChartContainer",
      "stackedChartContainer"
    ];
    
    const resizeObserver = new ResizeObserver((entries) => {
      for (let entry of entries) {
        const id = entry.target.id;
        console.log(`[ResizeObserver] ${id} resized:`, entry.contentRect.width, "x", entry.contentRect.height);
        
        // Trigger appropriate chart update based on container ID
        if (id === "trendChartContainer") {
          updateTrendChartBelow();
        } else if (id === "scatterChartContainer") {
          updateScatterChart();
        } else if (id === "heatmapChartContainer") {
          updateHeatmapChart();
        } else if (id === "stackedChartContainer") {
          updateStackedChart();
        }
      }
    });
    
    // Observe all chart containers
    containerIds.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        resizeObserver.observe(el);
        console.log(`[ResizeObserver] Observing #${id}`);
      }
    });
  }
  
  // Keyboard shortcuts
  document.addEventListener("keydown", (e) => {
    if(e.key === "Escape" && isCompareMode){
      resetAppState();
    }
  });

  // Initialize all charts after data is loaded
  renderTimeSeries(); renderAgeChart(); renderSexChart(); renderSankey(); 
  updateAllCharts();
  
  // Setup ResizeObserver for responsive re-rendering
  setupResizeObservers();
})();

</script>
</body>
</html>
